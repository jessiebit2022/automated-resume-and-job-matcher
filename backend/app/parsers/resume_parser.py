import re
import spacy
from typing import List, Dict, Optional
import logging
from ..models.resume_data import ResumeData, PersonalInfo, Experience, Education, Certification

logger = logging.getLogger(__name__)

class ResumeParser:
    """Main resume parser using spaCy and regex patterns."""
    
    def __init__(self):
        self.nlp = None
        self.skill_keywords = self._load_skill_keywords()
        
    def load_model(self):
        """Load spaCy model."""
        try:
            self.nlp = spacy.load("en_core_web_sm")
            logger.info("spaCy model loaded successfully")
        except OSError:
            logger.error("spaCy model not found. Please install with: python -m spacy download en_core_web_sm")
            raise
    
    def _load_skill_keywords(self) -> Dict[str, List[str]]:\n        \"\"\"Load predefined skill keywords by category.\"\"\"\n        return {\n            'programming': [\n                'python', 'javascript', 'java', 'c++', 'c#', 'ruby', 'php', 'go', 'rust', 'kotlin',\n                'swift', 'typescript', 'scala', 'r', 'matlab', 'perl', 'shell', 'bash', 'powershell'\n            ],\n            'web_frameworks': [\n                'react', 'angular', 'vue', 'node.js', 'express', 'django', 'flask', 'spring', 'rails',\n                'laravel', 'asp.net', 'jquery', 'bootstrap', 'tailwind', 'next.js', 'nuxt.js'\n            ],\n            'databases': [\n                'mysql', 'postgresql', 'mongodb', 'redis', 'sqlite', 'oracle', 'sql server',\n                'dynamodb', 'cassandra', 'elasticsearch', 'firebase', 'mariadb'\n            ],\n            'cloud_devops': [\n                'aws', 'azure', 'gcp', 'docker', 'kubernetes', 'jenkins', 'terraform', 'ansible',\n                'ci/cd', 'git', 'github', 'gitlab', 'bitbucket', 'linux', 'ubuntu', 'centos'\n            ],\n            'data_science': [\n                'machine learning', 'deep learning', 'tensorflow', 'pytorch', 'scikit-learn',\n                'pandas', 'numpy', 'matplotlib', 'seaborn', 'jupyter', 'tableau', 'power bi'\n            ],\n            'mobile': [\n                'ios', 'android', 'react native', 'flutter', 'xamarin', 'ionic', 'cordova'\n            ],\n            'tools': [\n                'jira', 'confluence', 'slack', 'trello', 'figma', 'sketch', 'photoshop', 'illustrator',\n                'visual studio', 'intellij', 'eclipse', 'vim', 'emacs', 'sublime text'\n            ]\n        }\n    \n    def parse(self, text: str) -> ResumeData:\n        \"\"\"Parse resume text and extract structured data.\"\"\"\n        if not self.nlp:\n            self.load_model()\n        \n        # Create ResumeData object\n        resume_data = ResumeData()\n        resume_data.raw_text = text\n        \n        # Clean and preprocess text\n        cleaned_text = self._clean_text(text)\n        doc = self.nlp(cleaned_text)\n        \n        # Extract different sections\n        resume_data.personal_info = self._extract_personal_info(text, doc)\n        resume_data.skills = self._extract_skills(text, doc)\n        resume_data.experience = self._extract_experience(text, doc)\n        resume_data.education = self._extract_education(text, doc)\n        resume_data.summary = self._extract_summary(text, doc)\n        \n        # Calculate confidence score\n        resume_data.confidence_score = self._calculate_confidence_score(resume_data)\n        \n        return resume_data\n    \n    def _clean_text(self, text: str) -> str:\n        \"\"\"Clean and normalize text.\"\"\"\n        # Remove extra whitespace\n        text = re.sub(r'\\s+', ' ', text)\n        # Remove special characters but keep basic punctuation\n        text = re.sub(r'[^\\w\\s@.,-]', '', text)\n        return text.strip()\n    \n    def _extract_personal_info(self, text: str, doc) -> PersonalInfo:\n        \"\"\"Extract personal information from resume.\"\"\"\n        personal_info = PersonalInfo()\n        \n        # Extract email\n        email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        emails = re.findall(email_pattern, text)\n        if emails:\n            personal_info.email = emails[0]\n        \n        # Extract phone number\n        phone_pattern = r'(\\+?\\d{1,3}[-.\\s]?)?(\\(?\\d{3}\\)?[-.\\s]?)?\\d{3}[-.\\s]?\\d{4}'\n        phones = re.findall(phone_pattern, text)\n        if phones:\n            personal_info.phone = ''.join(phones[0]).strip()\n        \n        # Extract name (using named entities)\n        for ent in doc.ents:\n            if ent.label_ == \"PERSON\" and not personal_info.name:\n                personal_info.name = ent.text\n                break\n        \n        # Extract location\n        locations = [ent.text for ent in doc.ents if ent.label_ in [\"GPE\", \"LOC\"]]\n        if locations:\n            personal_info.location = locations[0]\n        \n        # Extract LinkedIn\n        linkedin_pattern = r'linkedin\\.com/in/[\\w-]+'\n        linkedin_matches = re.findall(linkedin_pattern, text.lower())\n        if linkedin_matches:\n            personal_info.linkedin = f\"https://{linkedin_matches[0]}\"\n        \n        # Extract GitHub\n        github_pattern = r'github\\.com/[\\w-]+'\n        github_matches = re.findall(github_pattern, text.lower())\n        if github_matches:\n            personal_info.github = f\"https://{github_matches[0]}\"\n        \n        return personal_info\n    \n    def _extract_skills(self, text: str, doc) -> List[str]:\n        \"\"\"Extract skills from resume text.\"\"\"\n        skills = set()\n        text_lower = text.lower()\n        \n        # Search for skills in all categories\n        for category, skill_list in self.skill_keywords.items():\n            for skill in skill_list:\n                if skill.lower() in text_lower:\n                    skills.add(skill.title())\n        \n        # Additional pattern matching for common skill formats\n        skill_patterns = [\n            r'skills?:?\\s*([^\\n]+)',\n            r'technologies?:?\\s*([^\\n]+)',\n            r'programming languages?:?\\s*([^\\n]+)',\n            r'tools?:?\\s*([^\\n]+)'\n        ]\n        \n        for pattern in skill_patterns:\n            matches = re.findall(pattern, text_lower)\n            for match in matches:\n                # Split by common delimiters\n                potential_skills = re.split(r'[,;|•]', match)\n                for skill in potential_skills:\n                    skill = skill.strip()\n                    if len(skill) > 2 and len(skill) < 30:  # Filter reasonable skill names\n                        skills.add(skill.title())\n        \n        return list(skills)\n    \n    def _extract_experience(self, text: str, doc) -> List[Experience]:\n        \"\"\"Extract work experience from resume.\"\"\"\n        experiences = []\n        \n        # Simple pattern matching for experience sections\n        # This is a basic implementation - could be enhanced with ML\n        experience_pattern = r'(\\d{4})\\s*[-–]\\s*(\\d{4}|present|current)'\n        date_matches = re.findall(experience_pattern, text.lower())\n        \n        # For now, create a basic experience entry if dates are found\n        if date_matches:\n            # This is a simplified extraction - in practice, you'd want more sophisticated parsing\n            exp = Experience(\n                company=\"Company Name\",  # Would extract from context\n                position=\"Position Title\",  # Would extract from context\n                duration=f\"{date_matches[0][0]} - {date_matches[0][1]}\",\n                description=\"Job description would be extracted here\"\n            )\n            experiences.append(exp)\n        \n        return experiences\n    \n    def _extract_education(self, text: str, doc) -> List[Education]:\n        \"\"\"Extract education information from resume.\"\"\"\n        education_list = []\n        \n        # Common degree patterns\n        degree_patterns = [\n            r'(bachelor|master|phd|doctorate|associate)\\s*(of|in|degree)?\\s*([^\\n,]+)',\n            r'(b\\.?a\\.?|b\\.?s\\.?|m\\.?a\\.?|m\\.?s\\.?|ph\\.?d\\.?)\\s*(in)?\\s*([^\\n,]+)'\n        ]\n        \n        for pattern in degree_patterns:\n            matches = re.findall(pattern, text.lower())\n            for match in matches:\n                degree = ' '.join(match).strip()\n                if degree:\n                    edu = Education(\n                        institution=\"University Name\",  # Would extract from context\n                        degree=degree.title(),\n                        field_of_study=\"Field of Study\"  # Would extract from context\n                    )\n                    education_list.append(edu)\n                    break  # For now, just take the first match\n        \n        return education_list\n    \n    def _extract_summary(self, text: str, doc) -> Optional[str]:\n        \"\"\"Extract summary/objective section.\"\"\"\n        summary_patterns = [\n            r'summary:?\\s*([^\\n]{50,300})',\n            r'objective:?\\s*([^\\n]{50,300})',\n            r'profile:?\\s*([^\\n]{50,300})'\n        ]\n        \n        for pattern in summary_patterns:\n            matches = re.findall(pattern, text.lower(), re.DOTALL)\n            if matches:\n                return matches[0].strip()\n        \n        return None\n    \n    def _calculate_confidence_score(self, resume_data: ResumeData) -> float:\n        \"\"\"Calculate confidence score based on extracted data completeness.\"\"\"\n        score = 0.0\n        \n        # Personal info completeness (30%)\n        if resume_data.personal_info.name:\n            score += 0.1\n        if resume_data.personal_info.email:\n            score += 0.1\n        if resume_data.personal_info.phone:\n            score += 0.1\n        \n        # Skills (25%)\n        if len(resume_data.skills) > 0:\n            score += min(0.25, len(resume_data.skills) * 0.05)\n        \n        # Experience (30%)\n        if len(resume_data.experience) > 0:\n            score += min(0.3, len(resume_data.experience) * 0.15)\n        \n        # Education (15%)\n        if len(resume_data.education) > 0:\n            score += 0.15\n        \n        return min(1.0, score)